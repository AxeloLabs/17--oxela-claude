#!/bin/bash

rm -rf /tmp/titanic-health-XXXXXX.log    

# Titanic Health Check - Firebase Cloud Audit
# Generated by Gemini based on specification

# [Phase 0 : Initialisation]
# [Phase 1 : Config Firebase]
# [Phase 1.5 : Git]
# [Phase 2 : Build]
# [Phase 3 : Tests]
# [Phase 4 : Emulators]
# [Phase 5 : Deploy]
# [Phase 6 : Génération HTML]

# TODO

# ==============================================================================
# 🚢 TITANIC HEALTH CHECK
#
# A comprehensive health check script for Turborepo/Firebase projects.
# This script audits configuration, Git status, builds, tests, emulators,
# and deployment readiness, generating an interactive HTML report.
#
# Version: 1.0.0
# Author: Gemini Code Assist
# ==============================================================================

# ---
# Script Configuration and Robustness
# ---
# set -e: Exit immediately if a command exits with a non-zero status.
# set -u: Treat unset variables as an error when substituting.
# set -o pipefail: The return value of a pipeline is the status of the last
#                  command to exit with a non-zero status, or zero if no
#                  command exited with a non-zero status.
set -euo pipefail

# ---
# Global Variables
# ---
# Timestamps
TIMESTAMP_START_ISO=""
TIMESTAMP_START_SECONDS=""

# Status
OVERALL_STATUS="OK" # Can be OK, WARNING, CRITICAL

# Paths
PROJECT_ROOT=""
REPORTS_DIR=""
LOG_FILE=""

# Data files for results
RESULTS_DIR=""
CONFIG_RESULTS_FILE=""
GIT_RESULTS_FILE=""

# ---
# Helper Functions
# ---

# Logging function
# Usage: log_msg "INFO" "This is an info message"
log_msg() {
    local type=$1
    local message=$2
    local timestamp
    timestamp=$(date +"%Y-%m-%d %H:%M:%S")    
    if [ -z "$LOG_FILE" ]; then
        echo "[$timestamp] [$type] [NO LOG FILE] $message"
    fi
    echo "[$timestamp] [$type] $message" | tee -a "$LOG_FILE"
}

# Function to find the project root
# It searches upwards from the current directory for a `turbo.json` file.
find_project_root() {
    local dir
    dir="$PWD"
    while [ "$dir" != "/" ]; do
        if [ -f "$dir/turbo.json" ]; then
            echo "$dir"
            return
        fi
        dir=$(dirname "$dir")
    done
    echo "" # Not found
}

# Masks a sensitive value, showing only the first 4 and last 4 characters.
# Usage: masked_value=$(mask_sensitive "your-secret-key")
mask_sensitive() {
    local value=$1
    local len=${#value}
    if [ "$len" -le 8 ]; then
        echo "****"
    else
        local start="${value:0:4}"
        local end="${value: -4}"
        echo "${start}****${end}"
    fi
}

# Cleanup function to be called on script exit
cleanup() {
    # Safely remove the temporary results directory if it exists
    if [ -n "${RESULTS_DIR:-}" ] && [ -d "$RESULTS_DIR" ]; then
        rm -rf "$RESULTS_DIR"
    fi
}

# ---
# PHASE 0: INITIALIZATION
# ---
initialize() {
    TIMESTAMP_START_ISO=$(date +"%Y-%m-%dT%H:%M:%S%z")
    TIMESTAMP_START_SECONDS=$(date +%s)

    log_msg "INFO" "PHASE 0: Initializing Health Check..."

    PROJECT_ROOT=$(find_project_root)
    if [ -z "$PROJECT_ROOT" ]; then
        log_msg "CRITICAL" "Could not find project root (turbo.json). Please run from within the project."
        exit 1
    fi
    log_msg "INFO" "Project root detected: $PROJECT_ROOT"
    cd "$PROJECT_ROOT"

    # Create reports and results directory
    REPORTS_DIR="$PROJECT_ROOT/apps/admin/reports"
    mkdir -p "$REPORTS_DIR"
    log_msg "INFO" "Reports will be saved in: $REPORTS_DIR"

    RESULTS_DIR=$(mktemp -d)
    log_msg "INFO" "Intermediate results will be stored in: $RESULTS_DIR"
    CONFIG_RESULTS_FILE="$RESULTS_DIR/config_results.json"
    GIT_RESULTS_FILE="$RESULTS_DIR/git_results.json"
    # Initialize a structured JSON object for all config results, including the new coherence section
    echo '{"files": [], "environments": {"firebaserc": null, "firebase_json": null, "env_files": []}, "coherence": {"checks": [], "divergences": []}}' | jq '.' > "$CONFIG_RESULTS_FILE"
}

# ---
# PHASE 1: FIREBASE CONFIGURATION
# ---

# 1.1: Detect configuration files
detect_config_files() {
    log_msg "INFO" "PHASE 1.1: Detecting Firebase configuration files..."
    local temp_json_array="[]"

    local files_to_check=(
        "firebase.json"
        ".firebaserc"
        "firestore.rules"
        "firestore.indexes.json"
        "storage.rules"
        "database.rules.json"
    )

    # Find files in root
    for file_pattern in "${files_to_check[@]}"; do
        while IFS= read -r file_path; do
            if [ -n "$file_path" ]; then
                local last_mod
                last_mod=$(stat -f "%Sm" -t "%Y-%m-%dT%H:%M:%S%z" "$file_path")
                local readable="MANQUANT"
                [ -r "$file_path" ] && readable="LISIBLE"
                
                local json_obj
                json_obj=$(jq -n \
                    --arg file "$(basename "$file_path")" \
                    --arg path "$file_path" \
                    --arg status "TROUVÉ" \
                    --arg readable "$readable" \
                    --arg last_mod "$last_mod" \
                    '{file: $file, path: $path, status: $status, readable: $readable, last_modified: $last_mod}')
                temp_json_array=$(echo "$temp_json_array" | jq --argjson obj "$json_obj" '. + [$obj]')
            fi
        done < <(find . -maxdepth 1 -name "$file_pattern" -type f)
    done

    # Update the main results file
    jq --argjson arr "$temp_json_array" '.files = $arr' "$CONFIG_RESULTS_FILE" > "$CONFIG_RESULTS_FILE.tmp" && mv "$CONFIG_RESULTS_FILE.tmp" "$CONFIG_RESULTS_FILE"
}

# 1.2: Extract environments and keys
extract_environments_and_keys() {
    log_msg "INFO" "PHASE 1.2: Extracting environments and keys..."

    # --- Parse .firebaserc ---
    if [ -f ".firebaserc" ]; then
        log_msg "INFO" "Parsing .firebaserc..."
        local firebaserc_json
        firebaserc_json=$(jq '.projects' .firebaserc)
        jq --argjson projects "$firebaserc_json" '.environments.firebaserc = $projects' "$CONFIG_RESULTS_FILE" > "$CONFIG_RESULTS_FILE.tmp" && mv "$CONFIG_RESULTS_FILE.tmp" "$CONFIG_RESULTS_FILE"
    else
        log_msg "WARNING" ".firebaserc not found."
    fi

    # --- Parse firebase.json ---
    if [ -f "firebase.json" ]; then
        log_msg "INFO" "Parsing firebase.json for services..."
        local services_json
        services_json=$(jq '{
            projectId: (.projectId // null),
            hosting: (.hosting // null),
            functions: (.functions // null),
            firestore: (.firestore // null),
            storage: (.storage // null),
            emulators: (.emulators // null),
            dataconnect: (.dataconnect // null)
        }' firebase.json)
        jq --argjson services "$services_json" '.environments.firebase_json = $services' "$CONFIG_RESULTS_FILE" > "$CONFIG_RESULTS_FILE.tmp" && mv "$CONFIG_RESULTS_FILE.tmp" "$CONFIG_RESULTS_FILE"
    else
        log_msg "CRITICAL" "firebase.json not found."
        OVERALL_STATUS="CRITICAL"
    fi

    # --- Scan .env* files ---
    log_msg "INFO" "Scanning .env* files for Firebase keys..."
    local env_files
    env_files=$(find ./apps -name ".env*")
    local temp_env_array="[]"

    for file in $env_files; do
        local app_name
        app_name=$(echo "$file" | cut -d'/' -f3)
        local env_name
        env_name=$(basename "$file" | sed 's/\.env\.//' | sed 's/\.env//')
        [ -z "$env_name" ] && env_name="default"

        local file_vars_json="{}"
        file_vars_json=$(jq -n --arg app "$app_name" --arg env "$env_name" --arg file "$file" '{app: $app, environment: $env, file: $file, keys: {}}')

        # Grep for all relevant Firebase variables
        while IFS= read -r line; do
            # Improved regex to handle optional prefixes and stop at comments
            if [[ "$line" =~ ^(NEXT_PUBLIC_FIREBASE_|VITE_FIREBASE_|FIREBASE_)?(API_KEY|AUTH_DOMAIN|PROJECT_ID|STORAGE_BUCKET|MESSAGING_SENDER_ID|APP_ID|DATA_CONNECT_URL)=([^#]*) ]]; then
                # Portable way to convert to lowercase
                local key=$(echo "${BASH_REMATCH[2]}" | tr '[:upper:]' '[:lower:]')
                key=${key//_/-} # api_key -> api-key
                local value="${BASH_REMATCH[3]}"
                
                # Remove quotes if present
                value="${value%\"}"
                value="${value#\"}"
                value="${value%\'}"
                value="${value#\'}"

                # Trim whitespace
                value=$(echo "$value" | xargs)

                local display_value="$value"
                if [[ "$key" == "api-key" ]]; then
                    display_value=$(mask_sensitive "$value")
                fi

                file_vars_json=$(echo "$file_vars_json" | jq --arg k "$key" --arg v "$display_value" '.keys[$k] = $v')
            fi
        done < <(grep -E '^(NEXT_PUBLIC_FIREBASE_|VITE_FIREBASE_|FIREBASE_)' "$file" || true)

        temp_env_array=$(echo "$temp_env_array" | jq --argjson obj "$file_vars_json" '. + [$obj]')
    done

    jq --argjson arr "$temp_env_array" '.environments.env_files = $arr' "$CONFIG_RESULTS_FILE" > "$CONFIG_RESULTS_FILE.tmp" && mv "$CONFIG_RESULTS_FILE.tmp" "$CONFIG_RESULTS_FILE"
}

# 1.3: Verify configuration coherence
verify_config_coherence() {
    log_msg "INFO" "PHASE 1.3: Verifying configuration coherence..."
    local temp_coherence_array="[]"
    local temp_divergences_array="[]"

    # --- Check for mandatory files ---
    if ! jq -e '.files[] | select(.file == ".firebaserc")' "$CONFIG_RESULTS_FILE" > /dev/null; then
        log_msg "CRITICAL" ".firebaserc is missing. This is a critical configuration file."
        OVERALL_STATUS="CRITICAL"
        temp_coherence_array=$(echo "$temp_coherence_array" | jq '. + [{"check": "Presence of .firebaserc", "status": "ERROR", "message": ".firebaserc file is missing"}]')
    else
        temp_coherence_array=$(echo "$temp_coherence_array" | jq '. + [{"check": "Presence of .firebaserc", "status": "OK", "message": ".firebaserc found"}]')
    fi

    if ! jq -e '.files[] | select(.file == "firebase.json")' "$CONFIG_RESULTS_FILE" > /dev/null; then
        log_msg "CRITICAL" "firebase.json is missing. This is a critical configuration file."
        OVERALL_STATUS="CRITICAL"
        temp_coherence_array=$(echo "$temp_coherence_array" | jq '. + [{"check": "Presence of firebase.json", "status": "ERROR", "message": "firebase.json file is missing"}]')
    else
        temp_coherence_array=$(echo "$temp_coherence_array" | jq '. + [{"check": "Presence of firebase.json", "status": "OK", "message": "firebase.json found"}]')
    fi

    # If critical files are missing, offer to generate them and exit
    if [ "$OVERALL_STATUS" == "CRITICAL" ]; then
        read -p "Configuration Firebase incomplète détectée. Voulez-vous que Gemini génère les fichiers manquants ? (y/n) " -r
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo ""
            log_msg "GEMINI" "Génération du prompt pour la configuration Firebase..."
            echo "----------------------------------------------------------------"
            echo "Generate missing Firebase configuration files for a Turborepo project with 3 apps (admin, dashboard, public)."
            echo "Project structure detected: apps/admin, apps/dashboard, apps/vitrine."
            echo "Create firebase.json with hosting configuration for all apps and .firebaserc with default project alias."
            echo "Use placeholder project ID 'my-firebase-project'."
            echo "----------------------------------------------------------------"
        fi
        return # Stop this phase
    fi

    # --- Compare projectIds for consistency ---
    local ref_project_id
    ref_project_id=$(jq -r '.environments.firebaserc.default // empty' "$CONFIG_RESULTS_FILE")

    if [ -z "$ref_project_id" ]; then
        log_msg "WARNING" "No default project ID found in .firebaserc."
        temp_coherence_array=$(echo "$temp_coherence_array" | jq '. + [{"check": "Default projectId in .firebaserc", "status": "WARNING", "message": "Not set"}]')
    else
        temp_divergences_array=$(echo "$temp_divergences_array" | jq --arg pid "$ref_project_id" '. + [{"source": ".firebaserc (default)", "projectId": $pid}]')
    fi

    # Compare with firebase.json
    local firebase_json_pid
    firebase_json_pid=$(jq -r '.environments.firebase_json.projectId // empty' "$CONFIG_RESULTS_FILE")
    if [ -n "$firebase_json_pid" ]; then
        temp_divergences_array=$(echo "$temp_divergences_array" | jq --arg pid "$firebase_json_pid" '. + [{"source": "firebase.json", "projectId": $pid}]')
        if [ -n "$ref_project_id" ] && [ "$ref_project_id" != "$firebase_json_pid" ]; then
            log_msg "WARNING" "projectId in firebase.json ('$firebase_json_pid') differs from .firebaserc ('$ref_project_id')."
            OVERALL_STATUS="WARNING"
        fi
    fi

    # Compare with .env files
    local env_pids
    env_pids=$(jq -c '.environments.env_files[] | select((.file | endswith(".example") | not) and .keys."project-id" != null and .keys."project-id" != "") | {file: .file, projectId: .keys."project-id"}' "$CONFIG_RESULTS_FILE")
    while IFS= read -r env_pid_obj; do
        if [ -n "$env_pid_obj" ]; then
            local file=$(echo "$env_pid_obj" | jq -r '.file')
            local pid=$(echo "$env_pid_obj" | jq -r '.projectId')
            temp_divergences_array=$(echo "$temp_divergences_array" | jq --arg file "$file" --arg pid "$pid" '. + [{"source": $file, "projectId": $pid}]')
            if [ -n "$ref_project_id" ] && [ "$ref_project_id" != "$pid" ]; then
                log_msg "WARNING" "projectId in $file ('$pid') differs from .firebaserc ('$ref_project_id')."
                OVERALL_STATUS="WARNING"
            fi
        fi
    done <<< "$env_pids"

    local unique_pids
    unique_pids=$(echo "$temp_divergences_array" | jq -r 'map(.projectId) | unique | length')
    if [ "$unique_pids" -le 1 ]; then
        log_msg "INFO" "Project IDs are consistent across all detected files."
        temp_coherence_array=$(echo "$temp_coherence_array" | jq '. + [{"check": "Project ID Consistency", "status": "OK", "message": "All project IDs match"}]')
    else
        log_msg "WARNING" "Project ID inconsistency detected. See details in the report."
        OVERALL_STATUS="WARNING"
        temp_coherence_array=$(echo "$temp_coherence_array" | jq '. + [{"check": "Project ID Consistency", "status": "WARNING", "message": "Mismatch in project IDs found"}]')
    fi

    # --- Check for presence of API keys and authDomain pattern ---
    local api_key_count
    api_key_count=$(jq '[.environments.env_files[].keys | select(."api-key")] | length' "$CONFIG_RESULTS_FILE")
    if [ "$api_key_count" -eq 0 ]; then
        log_msg "WARNING" "No Firebase API keys were detected in any .env files."
        OVERALL_STATUS="WARNING"
        temp_coherence_array=$(echo "$temp_coherence_array" | jq '. + [{"check": "API Key Presence", "status": "WARNING", "message": "No API keys found"}]')
    fi

    # --- Check for corresponding rule files ---
    local services
    services=$(jq -r '.environments.firebase_json | del(.projectId, .emulators, .hosting) | to_entries[] | select(.value | (type == "object" or type == "array") and length > 0) | .key' "$CONFIG_RESULTS_FILE")
    for service in $services; do
        local rule_file=""
        case $service in
            "firestore") rule_file="firestore.rules" ;;
            "storage") rule_file="storage.rules" ;;
            "database") rule_file="database.rules.json" ;;
        esac

        if [ -n "$rule_file" ]; then
            if [ -f "$rule_file" ]; then
                log_msg "INFO" "Found rule file for $service: $rule_file"
                temp_coherence_array=$(echo "$temp_coherence_array" | jq --arg s "$service" '. + [{"check": ("Rule file for " + $s), "status": "OK", "message": "Found"}]')
            else
                log_msg "WARNING" "$service is configured in firebase.json, but its rule file '$rule_file' is missing."
                OVERALL_STATUS="WARNING"
                temp_coherence_array=$(echo "$temp_coherence_array" | jq --arg s "$service" '. + [{"check": ("Rule file for " + $s), "status": "WARNING", "message": "Missing"}]')
            fi
        fi
    done

    # --- Final update to results file ---
    jq --argjson checks "$temp_coherence_array" --argjson divs "$temp_divergences_array" \
        '.coherence.checks = $checks | .coherence.divergences = $divs' \
        "$CONFIG_RESULTS_FILE" > "$CONFIG_RESULTS_FILE.tmp" && mv "$CONFIG_RESULTS_FILE.tmp" "$CONFIG_RESULTS_FILE"
}

# ---
# PHASE 1.5: GIT STATUS
# ---

# 1.5.1: Check working directory status
check_git_status() {
    log_msg "INFO" "PHASE 1.5.1: Checking Git working directory status..."
    # Initialize JSON file
    echo '{"status": "NOT_A_REPO", "files": [], "stats": {}}' > "$GIT_RESULTS_FILE"

    if [ ! -d ".git" ]; then
        log_msg "WARNING" "Not a Git repository. Skipping Git checks."
        if [ "$OVERALL_STATUS" != "CRITICAL" ]; then OVERALL_STATUS="WARNING"; fi
        jq '.coherence.checks += [{"check": "Git Repository", "status": "WARNING", "message": "Not a Git repository"}]' "$CONFIG_RESULTS_FILE" > "$CONFIG_RESULTS_FILE.tmp" && mv "$CONFIG_RESULTS_FILE.tmp" "$CONFIG_RESULTS_FILE"
        return
    fi

    local git_status_output
    git_status_output=$(git status --porcelain)

    local modified_count=0
    local untracked_count=0
    local added_count=0
    local deleted_count=0
    local conflict_count=0
    local git_status="CLEAN"

    if [ -n "$git_status_output" ]; then
        # Use grep with -c flag for counting, which is more efficient than piping to wc -l
        modified_count=$(echo "$git_status_output" | grep -c "^ M " || true)
        untracked_count=$(echo "$git_status_output" | grep -c "^??" || true)
        added_count=$(echo "$git_status_output" | grep -c "^A " || true)
        deleted_count=$(echo "$git_status_output" | grep -c "^ D" || true)
        conflict_count=$(echo "$git_status_output" | grep -c -E "^(UU|AA|DD|AU|UA|UD|DU)" || true)
        
        if [ "$conflict_count" -gt 0 ]; then
            git_status="CONFLICT"
            OVERALL_STATUS="CRITICAL"
            local conflict_files
            conflict_files=$(echo "$git_status_output" | grep -E "^(UU|AA|DD|AU|UA|UD|DU)")
            log_msg "CRITICAL" "GIT CONFLICTS DETECTED - Manual resolution required."
            echo "----------------------------------------------------------------" >&2
            echo "⚠️ CONFLITS GIT DÉTECTÉS - Résolution manuelle requise avant de continuer." >&2
            echo "Fichiers en conflit :" >&2
            echo "$conflict_files" >&2
            echo "" >&2
            echo "Gemini ne peut pas résoudre automatiquement les conflits de merge." >&2
            echo "Veuillez résoudre manuellement avec 'git status' et 'git mergetool'." >&2
            echo "----------------------------------------------------------------" >&2
            exit 1
        else
            git_status="DIRTY"
            if [ "$OVERALL_STATUS" != "CRITICAL" ]; then OVERALL_STATUS="WARNING"; fi
        fi
    fi

    local files_json
    files_json=$(echo "$git_status_output" | head -n 20 | jq -R -s 'split("\n") | map(select(length > 0))')

    jq -n \
      --arg status "$git_status" \
      --argjson files "$files_json" \
      --argjson mc "$modified_count" \
      --argjson uc "$untracked_count" \
      --argjson ac "$added_count" \
      --argjson dc "$deleted_count" \
      --argjson cc "$conflict_count" \
      '{status: $status, files: $files, stats: {modified: $mc, untracked: $uc, added: $ac, deleted: $dc, conflicts: $cc}}' > "$GIT_RESULTS_FILE"
}

main() {
    echo "========================================"
    echo "🚢 TITANIC HEALTH CHECK"
    echo "   Firebase Cloud Audit Tool"
    echo "========================================"
    echo ""

    # Set trap at the very beginning of the main script execution
    trap cleanup EXIT INT TERM
    
    # Use mktemp to create a secure temporary log file
    LOG_FILE=$(mktemp /tmp/titanic-health-XXXXXX.log)
    if [ -z "$LOG_FILE" ] || [ ! -f "$LOG_FILE" ]; then
        echo "[FATAL] Could not create temporary log file. Exiting."
        exit 1
    fi

    initialize

    echo ""
    log_msg "INFO" "PHASE 1: Auditing Firebase Configuration"
    
    detect_config_files
    extract_environments_and_keys
    verify_config_coherence

    log_msg "INFO" "Firebase config analysis complete. Results:"
    jq '.' "$CONFIG_RESULTS_FILE" | tee -a "$LOG_FILE"

    echo ""
    log_msg "INFO" "PHASE 1.5: Auditing Git Repository"
    check_git_status
    log_msg "INFO" "Git status analysis complete. Results:"
    jq '.' "$GIT_RESULTS_FILE" | tee -a "$LOG_FILE"

    
    # ... The rest of the phases will be implemented here ...

    log_msg "INFO" "Health check script started successfully."
}

main "$@"