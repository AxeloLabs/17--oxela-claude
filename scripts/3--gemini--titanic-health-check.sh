#!/bin/bash

rm -rf /tmp/titanic-health-XXXXXX.log    

# Titanic Health Check - Firebase Cloud Audit
# Generated by Gemini based on specification

# [Phase 0 : Initialisation]
# [Phase 1 : Config Firebase]
# [Phase 1.5 : Git]
# [Phase 2 : Build]
# [Phase 3 : Tests]
# [Phase 4 : Emulators]
# [Phase 5 : Deploy]
# [Phase 6 : GÃ©nÃ©ration HTML]

# TODO

# ==============================================================================
# ðŸš¢ TITANIC HEALTH CHECK
#
# A comprehensive health check script for Turborepo/Firebase projects.
# This script audits configuration, Git status, builds, tests, emulators,
# and deployment readiness, generating an interactive HTML report.
#
# Version: 1.0.0
# Author: Gemini Code Assist
# ==============================================================================

# ---
# Script Configuration and Robustness
# ---
# set -e: Exit immediately if a command exits with a non-zero status.
# set -u: Treat unset variables as an error when substituting.
# set -o pipefail: The return value of a pipeline is the status of the last
#                  command to exit with a non-zero status, or zero if no
#                  command exited with a non-zero status.
set -euo pipefail

# ---
# Global Variables
# ---
# Timestamps
TIMESTAMP_START_ISO=""
TIMESTAMP_START_SECONDS=""

# Status
OVERALL_STATUS="OK" # Can be OK, WARNING, CRITICAL

# Paths
PROJECT_ROOT=""
REPORTS_DIR=""
LOG_FILE=""

# Data files for results
RESULTS_DIR=""
CONFIG_RESULTS_FILE=""
GIT_RESULTS_FILE=""

# ---
# Helper Functions
# ---

# Logging function
# Usage: log_msg "INFO" "This is an info message"
log_msg() {
    local type=$1
    local message=$2
    local timestamp
    timestamp=$(date +"%Y-%m-%d %H:%M:%S")    
    if [ -z "$LOG_FILE" ]; then
        echo "[$timestamp] [$type] [NO LOG FILE] $message"
    fi
    echo "[$timestamp] [$type] $message" | tee -a "$LOG_FILE"
}

# Function to find the project root
# It searches upwards from the current directory for a `turbo.json` file.
find_project_root() {
    local dir
    dir="$PWD"
    while [ "$dir" != "/" ]; do
        if [ -f "$dir/turbo.json" ]; then
            echo "$dir"
            return
        fi
        dir=$(dirname "$dir")
    done
    echo "" # Not found
}

# Masks a sensitive value, showing only the first 4 and last 4 characters.
# Usage: masked_value=$(mask_sensitive "your-secret-key")
mask_sensitive() {
    local value=$1
    local len=${#value}
    if [ "$len" -le 8 ]; then
        echo "****"
    else
        local start="${value:0:4}"
        local end="${value: -4}"
        echo "${start}****${end}"
    fi
}

# Cleanup function to be called on script exit
cleanup() {
    # Safely remove the temporary results directory if it exists
    if [ -n "${RESULTS_DIR:-}" ] && [ -d "$RESULTS_DIR" ]; then
        rm -rf "$RESULTS_DIR"
    fi
}

# ---
# PHASE 0: INITIALIZATION
# ---
initialize() {
    TIMESTAMP_START_ISO=$(date +"%Y-%m-%dT%H:%M:%S%z")
    TIMESTAMP_START_SECONDS=$(date +%s)

    log_msg "INFO" "PHASE 0: Initializing Health Check..."

    PROJECT_ROOT=$(find_project_root)
    if [ -z "$PROJECT_ROOT" ]; then
        log_msg "CRITICAL" "Could not find project root (turbo.json). Please run from within the project."
        exit 1
    fi
    log_msg "INFO" "Project root detected: $PROJECT_ROOT"
    cd "$PROJECT_ROOT"

    # Create reports and results directory
    REPORTS_DIR="$PROJECT_ROOT/apps/admin/reports"
    mkdir -p "$REPORTS_DIR"
    log_msg "INFO" "Reports will be saved in: $REPORTS_DIR"

    RESULTS_DIR=$(mktemp -d)
    log_msg "INFO" "Intermediate results will be stored in: $RESULTS_DIR"
    CONFIG_RESULTS_FILE="$RESULTS_DIR/config_results.json"
    # Initialize a structured JSON object for all config results
    echo '{"files": [], "environments": {"firebaserc": null, "firebase_json": null, "env_files": []}}' | jq '.' > "$CONFIG_RESULTS_FILE"
}

# ---
# PHASE 1: FIREBASE CONFIGURATION
# ---

# 1.1: Detect configuration files
detect_config_files() {
    log_msg "INFO" "PHASE 1.1: Detecting Firebase configuration files..."
    local temp_json_array="[]"

    local files_to_check=(
        "firebase.json"
        ".firebaserc"
        "firestore.rules"
        "firestore.indexes.json"
        "storage.rules"
        "database.rules.json"
    )

    # Find files in root
    for file_pattern in "${files_to_check[@]}"; do
        while IFS= read -r file_path; do
            if [ -n "$file_path" ]; then
                local last_mod
                last_mod=$(stat -f "%Sm" -t "%Y-%m-%dT%H:%M:%S%z" "$file_path")
                local readable="MANQUANT"
                [ -r "$file_path" ] && readable="LISIBLE"
                
                local json_obj
                json_obj=$(jq -n \
                    --arg file "$(basename "$file_path")" \
                    --arg path "$file_path" \
                    --arg status "TROUVÃ‰" \
                    --arg readable "$readable" \
                    --arg last_mod "$last_mod" \
                    '{file: $file, path: $path, status: $status, readable: $readable, last_modified: $last_mod}')
                temp_json_array=$(echo "$temp_json_array" | jq --argjson obj "$json_obj" '. + [$obj]')
            fi
        done < <(find . -maxdepth 1 -name "$file_pattern" -type f)
    done

    # Update the main results file
    jq --argjson arr "$temp_json_array" '.files = $arr' "$CONFIG_RESULTS_FILE" > "$CONFIG_RESULTS_FILE.tmp" && mv "$CONFIG_RESULTS_FILE.tmp" "$CONFIG_RESULTS_FILE"
}

# 1.2: Extract environments and keys
extract_environments_and_keys() {
    log_msg "INFO" "PHASE 1.2: Extracting environments and keys..."

    # --- Parse .firebaserc ---
    if [ -f ".firebaserc" ]; then
        log_msg "INFO" "Parsing .firebaserc..."
        local firebaserc_json
        firebaserc_json=$(jq '.projects' .firebaserc)
        jq --argjson projects "$firebaserc_json" '.environments.firebaserc = $projects' "$CONFIG_RESULTS_FILE" > "$CONFIG_RESULTS_FILE.tmp" && mv "$CONFIG_RESULTS_FILE.tmp" "$CONFIG_RESULTS_FILE"
    else
        log_msg "WARNING" ".firebaserc not found."
    fi

    # --- Parse firebase.json ---
    if [ -f "firebase.json" ]; then
        log_msg "INFO" "Parsing firebase.json for services..."
        local services_json
        services_json=$(jq '{
            projectId: (.projectId // null),
            hosting: (.hosting // null),
            functions: (.functions // null),
            firestore: (.firestore // null),
            storage: (.storage // null),
            emulators: (.emulators // null),
            dataconnect: (.dataconnect // null)
        }' firebase.json)
        jq --argjson services "$services_json" '.environments.firebase_json = $services' "$CONFIG_RESULTS_FILE" > "$CONFIG_RESULTS_FILE.tmp" && mv "$CONFIG_RESULTS_FILE.tmp" "$CONFIG_RESULTS_FILE"
    else
        log_msg "CRITICAL" "firebase.json not found."
        OVERALL_STATUS="CRITICAL"
    fi

    # --- Scan .env* files ---
    log_msg "INFO" "Scanning .env* files for Firebase keys..."
    local env_files
    env_files=$(find ./apps -name ".env*")
    local temp_env_array="[]"

    for file in $env_files; do
        local app_name
        app_name=$(echo "$file" | cut -d'/' -f3)
        local env_name
        env_name=$(basename "$file" | sed 's/\.env\.//' | sed 's/\.env//')
        [ -z "$env_name" ] && env_name="default"

        local file_vars_json="{}"
        file_vars_json=$(jq -n --arg app "$app_name" --arg env "$env_name" --arg file "$file" '{app: $app, environment: $env, file: $file, keys: {}}')

        # Grep for all relevant Firebase variables
        while IFS= read -r line; do
            if [[ "$line" =~ ^(NEXT_PUBLIC_FIREBASE_|VITE_FIREBASE_|FIREBASE_)?(API_KEY|AUTH_DOMAIN|PROJECT_ID|STORAGE_BUCKET|MESSAGING_SENDER_ID|APP_ID|DATA_CONNECT_URL)=(.*) ]]; then
                local key="${BASH_REMATCH[2],,}" # a_b_c -> a_b_c
                key=${key//_/-} # a-b-c -> a-b-c
                local value="${BASH_REMATCH[3]}"
                
                # Remove quotes if present
                value="${value%\"}"
                value="${value#\"}"
                value="${value%\'}"
                value="${value#\'}"

                local display_value="$value"
                if [[ "$key" == "api-key" ]]; then
                    display_value=$(mask_sensitive "$value")
                fi

                file_vars_json=$(echo "$file_vars_json" | jq --arg k "$key" --arg v "$display_value" '.keys[$k] = $v')
            fi
        done < <(grep -E '^(NEXT_PUBLIC_FIREBASE_|VITE_FIREBASE_|FIREBASE_)' "$file" || true)

        temp_env_array=$(echo "$temp_env_array" | jq --argjson obj "$file_vars_json" '. + [$obj]')
    done

    jq --argjson arr "$temp_env_array" '.environments.env_files = $arr' "$CONFIG_RESULTS_FILE" > "$CONFIG_RESULTS_FILE.tmp" && mv "$CONFIG_RESULTS_FILE.tmp" "$CONFIG_RESULTS_FILE"
}

main() {
    echo "========================================"
    echo "ðŸš¢ TITANIC HEALTH CHECK"
    echo "   Firebase Cloud Audit Tool"
    echo "========================================"
    echo ""

    # Set trap at the very beginning of the main script execution
    trap cleanup EXIT INT TERM
    
    # Use mktemp to create a secure temporary log file
    LOG_FILE=$(mktemp /tmp/titanic-health-XXXXXX.log)
    if [ -z "$LOG_FILE" ] || [ ! -f "$LOG_FILE" ]; then
        echo "[FATAL] Could not create temporary log file. Exiting."
        exit 1
    fi

    initialize

    echo ""
    log_msg "INFO" "PHASE 1: Auditing Firebase Configuration"
    
    detect_config_files
    extract_environments_and_keys

    log_msg "INFO" "Firebase config analysis complete. Results:"
    jq '.' "$CONFIG_RESULTS_FILE" | tee -a "$LOG_FILE"

    
    # ... The rest of the phases will be implemented here ...

    log_msg "INFO" "Health check script started successfully."
}

main "$@"